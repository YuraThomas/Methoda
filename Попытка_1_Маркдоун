2025

Авторы: KeK, GaSoline

Админы ТГ канала “Дневник ботающего дракоши”

Методичка диффура

Часть 5. Высшая цифровая схемотехника

Содержание

[Вступление [2](#вступление)](#вступление)

[Лекция 1. АЛУ. [3](#лекция-1.-алу.)](#лекция-1.-алу.)

[Лекция 2. Регистровый файл. [14](#лекция-2.-регистровый-файл.)](#лекция-2.-регистровый-файл.)

[Лекция 3. Немного про память команд. [24](#лекция-3.-немного-про-память-команд.)](#лекция-3.-немного-про-память-команд.)

[Лекция 4. Простейший процессор. [26](#лекция-4.-простейший-процессор.)](#лекция-4.-простейший-процессор.)

[Лекция 5. Прошивка “Cobra” [34](#лекция-5.-прошивка-cobra)](#лекция-5.-прошивка-cobra)

[Лекция 6. Простейший RISC-V. [42](#лекция-6.-простейший-risc-v.)](#лекция-6.-простейший-risc-v.)

[Лекция 7. Декодер инструкций RISC-V. [49](#лекция-7.-декодер-инструкций-risc-v.)](#лекция-7.-декодер-инструкций-risc-v.)

[Лекция 8. RISC-V на Verilog [66](#лекция-8.-risc-v-на-verilog)](#лекция-8.-risc-v-на-verilog)

[Лекция 9. Прошивка RISC-V. [74](#лекция-9.-прошивка-risc-v.)](#лекция-9.-прошивка-risc-v.)

[Полезные ссылки (+источники). [81](#полезные-ссылки-источники.)](#полезные-ссылки-источники.)

# Вступление

Пытаясь разобраться в том, что понаписал Харис-Харис и другие уважаемые авторы по архитектурам процессора/высшей цифре я несколько осознал, что тема как высших базовых элементов (таких как АЛУ, регистровый файл, память команд, декодер инструкций), так и самого процессора RISC-V не раскрыта (большая часть авторов довольствуется красивыми картиночками без примеров, что весьма сильно мешало мне при изучении архитектуры процессора).

Поэтому автор (KeK) как раз и решил сделать краткое введение по базовым коробочкам, из которых состоит процессор, после которого уже будут более понятным и очевидным чтение других книг (и написание своего RISC-V).

Также, в качестве эксперимента данную методичку частично писал и другой автор (GaSoline), что было весьма забавным опытом (всегда хотелось удалить текст другого автора и переписать его так, как удобно мне)

Авторы специально делают много вставок из Verilog (кому хочется поиграться с ним – добро пожаловать на гитхаб) и RTL что синтезируется из него тем же Quartus, чтобы читатель сначала прочитал красивую теорию про какой-то блок, а потом увидел то, как он синтезируется на самом деле. (хотя бы в RTL).

# Лекция 1. АЛУ.

**Некое вступление**

В данной небольшой статье мы рассмотри АЛУ и приведем тривиальные примеры (а потом уже читатель сам под нужную ему архитектуру сделает). На самом деле АЛУ и другие компоненты процессора это весьма очевидная штуковина.

**Что такое АЛУ?**

АЛУ – арифметико-логическое устройство, а если чуток более развернуто, то это штуковина, на которую приходит управляющий сигнал и некий входной сигнал, а она по управляющему сигналу (шине) выбирает операцию и исполняет ее над входными данными (еще, правда, есть такие штуковины как флаги, но про них будет в примерах на Verilog).

То есть, по данному описанию вырисовывается примерная схема АЛУ:

<img src="./media/image1.png" style="width:2.04167in;height:1.57219in" />

(Данный АЛУ умеет выполнять 4 функции над N-битным числом (элементами шины) и выдавать 1 из 4 функций по управляющему воздействию)

Как мы видим, это просто мультиплексор с некой комбинационной логикой на входах.

**Небольшой пример.**

<img src="./media/image2.png" style="width:2.16667in;height:1.64759in" />

Найти значение на выходе (в десятичной форме), если upr = 2, а D = 13

Так-как числа A и B это биты числа D в двоичной форме, то переведем D в этот вид (двоичный)

*D* = 13= 1101<sub>2</sub>

Тогда мы находим A и B:

*A* = 01<sub>2</sub> = 1

*B* = 11<sub>2</sub> = 3

*u**p**r* = 2= 10<sub>2</sub>, то у нас над числами A и B будет выполняться умножение

ТЕ, на выходе будет:

*o**u**t* = (*A* \* *B*) = 3= 0011<sub>2</sub>

Теперь, познакомившись более-менее с концепцией данного устройства, давайте реализовывать его на Verilog.

**АЛУ номер 1. Переключатор между 4 операциями.**

Данный пример будет вообще в отрыве от различных архитектур и систем, просто сделаем нечто, у которого можно выбрать операцию над входами. Числа пускай будут 32-битными (входы A, B и выход Out_ALU).

**Таблица операций на АЛУ**

<table>
<colgroup>
<col style="width: 49%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">Upr_ALU</th>
<th style="text-align: center;">Out_ALU</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">A | B</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">A &amp; B</td>
</tr>
</tbody>
</table>

**Описание на Verilog (но RTL схема выходит некрасивая).**

<img src="./media/image3.png" style="width:3.31944in;height:1.17341in" />

**Описание на Verilog с красивой RTL схемой (загнал операции ИЛИ, И в модули).**

<img src="./media/image4.png" style="width:3.11975in;height:2.48611in" />

<img src="./media/image5.png" style="width:2.93926in;height:1.54167in" />

<img src="./media/image6.png" style="width:2.94444in;height:1.47222in" />

**Тестирование первого АЛУ**

Тесты ниже не доказывают абсолютную работоспособность схемы, они лишь могут показать некие очевидные ошибки, если они есть, а для полной проверки схемы надо писать полный тестбенч (а тема данной статьи все-таки не совсем про Verilog и реализацию в нем тестбенчей). Ниже я привел быстрый тест схемы “ на глазок”.

**Тест операции 0**

<img src="./media/image7.png" style="width:6.48819in;height:0.53542in" />

Операция работает (выводит всегда 0).

**Тест операции 1**

<img src="./media/image8.png" style="width:6.48819in;height:0.55347in" />

Операция работает (выводит всегда 1).

**Тест операции 2**

<img src="./media/image9.png" style="width:6.49375in;height:0.59514in" />

Операция работает (делает A ИЛИ B)

**Тест операции 3**

<img src="./media/image10.png" style="width:6.48194in;height:0.38681in" />

Операция работает (делает A И B)

Да, в тесте 2 последних операций есть числа раскрытые не полностью (места не хватило), но автор их проверил, и на них АЛУ тоже работает верно

**Тест всех операций разом**

<img src="./media/image11.png" style="width:6.48194in;height:0.42847in" />

Как читатель может видеть, вроде бы все работает верно.

**RTL схема**

<img src="./media/image12.png" style="width:5.30303in;height:1.69765in" />

**АЛУ номер 2. Переключатор между 8 операциями + бит сравнения C.**

Если рассматривать АЛУ в отрыве от какой-либо (даже самой простой) архитектуры, то может быть непонятен смысл бита сравнения. Однако, если читатель поверит мне на слово, то концептуально простейший процессор/программируемое устройство должно уметь аппаратно реализовывать циклы и условные конструкции, бит C отвечает за верность выполнения условия (если C = 1 и должна выполняться проверка некоего условия (это зашито в командах, которыми мы прошиваем устройство), то выполняется нетрадиционный переход с одной строки памяти команд на другую (то есть, в обычном режиме у нас идет чтение 1 строчки кода, затем 2 строчки кода, затем 3 строчки кода и тд, но при выполнении неких условий (условная команда и C = 1) считыватель с памяти команд может перепрыгнуть на 7 строчек наверх по программе, или на 12 строчек вниз, что по сути своей и есть аппаратно реализованные условные конструкции и циклы).

Отходя от большого и красивого обоснования наличия данного бита (ограничимся пока что им) накидаем относительно разумный список команд:

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">Upr_ALU</th>
<th style="text-align: center;">C</th>
<th style="text-align: center;">Операции на АЛУ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Все равно, но пускай 0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Все равно, но пускай 0</td>
<td style="text-align: center;">A+B</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">Все равно, но пускай 0</td>
<td style="text-align: center;">A-B</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">Все равно, но пускай 0</td>
<td style="text-align: center;">A &amp; B</td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">Все равно, но пускай 0</td>
<td style="text-align: center;">A | B</td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;">1, если верно, иначе 0</td>
<td style="text-align: center;">A &gt; B</td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: center;">1, если верно, иначе 0</td>
<td style="text-align: center;">A == B</td>
</tr>
<tr>
<td style="text-align: center;">7</td>
<td style="text-align: center;">Все равно, но пускай 0</td>
<td style="text-align: center;">A &lt;&lt; 1 – сдвиг A на 1 налево</td>
</tr>
</tbody>
</table>

В арифметических операциях нам все равно на C, в условных операциях нам все равно на Out_ALU (а если нам на что-то все равно, то значение на выходе будет 0).

**Описание на Verilog.**

<img src="./media/image13.png" style="width:3.52652in;height:4.01389in" />

**RTL схема АЛУ.**

<img src="./media/image14.png" style="width:6.87996in;height:1.56818in" />

Как читатель видит, устройство весьма нехило в размере выросло.

**Тестирование второго АЛУ**

Ну что-ж, давайте начнем сие увлекательное действие, состоящее из тестов выхода АЛУ и C для каждой операции. Также, так-как возможно переполнение, но данный флаг (бит переполнения при операции) нами при данном АЛУ не предусмотрен, то будем давать тесты, при которых переполнения не будет.

**Тест операции 0 (выдает 0)**

<img src="./media/image15.png" style="width:6.49444in;height:0.67778in" />

**  
**

**Тест операции 1 (выдает A + B)**

<img src="./media/image16.png" style="width:6.48889in;height:0.68889in" />

**Тест операции 2 (выдает A – B)**

<img src="./media/image17.png" style="width:6.48889in;height:0.72778in" />

**Тест операции 3 (Логическое И)**

<img src="./media/image18.png" style="width:6.48889in;height:0.48333in" />

**Тест операции 4 (логическое ИЛИ)**

<img src="./media/image19.png" style="width:6.48889in;height:0.47778in" />

**Тест операции 5 ( A \> B, работает только для беззнаковых десятичных, желательно свой компаратор писать)**

<img src="./media/image20.png" style="width:6.48333in;height:0.47222in" />

**Тест операции 6 (A = B)**

<img src="./media/image21.png" style="width:6.48333in;height:0.66111in" />

**Тест операции 7 (сдвиг на 1 разряд числа A налево (для положительных чисел это примерно умножение на 2)**

<img src="./media/image22.png" style="width:6.49444in;height:0.67222in" />

Как читатель видит, АЛУ реализовано примерно так, как нам надо (только компаратор можно свой поставить, чтобы он знаковые числа обрабатывал (или встроенный модифицировать))

**АЛУ номер 3. Весьма близко к реальному RISC-V.**

<img src="./media/image23.png" style="width:3.54968in;height:0.84896in" />

Для выхода АЛУ (у нас вместо result_0 выход Out_ALU

<img src="./media/image24.png" style="width:4.80553in;height:2.125in" />

Для некоего характерного бита (флага), у нас, как и в прошлом АЛУ это будет бит C (результат логической операции)

<img src="./media/image25.png" style="width:3.79687in;height:1.40165in" />

В общем-то, 2 примера АЛУ выше должны были подвести нас к данной штуковине и, в общем-то, показать ее очевидность. Как и в прошлом АЛУ, ставим 0 на выходы, которые мы не используем.

Из новых моментов по сравнению с предыдущим АЛУ скорее большее внимание биту C и оформление кода (теперь, например, вместо кода операции сложения 5’d0 будем использовать ADD с помощью конструкции parameter, которая будет сама вместо ADD подставлять 5’d0). Автор не будет управляющий вход АЛУ разделять на 3 части, просто сделав его 5-битным.

**RTL схема АЛУ.**

<img src="./media/image26.png" style="width:6.36979in;height:1.51636in" />

**Описание АЛУ на Verilog (главный модуль).**

<img src="./media/image27.png" style="width:3.46212in;height:9.30926in" />

**Описание АЛУ на Verilog (модули).**

<img src="./media/image28.png" style="width:2.54545in;height:1.69697in" />

<img src="./media/image29.png" style="width:2.59715in;height:1.5in" />

<img src="./media/image30.png" style="width:2.92314in;height:1.56061in" />

**Тест АЛУ.**

В силу того, что операций весьма много, будем тестировать сразу несколько штук за тест (такой метод позволит найти, увы, только очевиднейшие ошибки).

**Операции ADD, SUB, SLTS (сложение, вычитание, знаковое сравнивание (выход на АЛУ)).**

<img src="./media/image31.png" style="width:6.95759in;height:0.80357in" />

**Операции XOR, OR, AND (сложение по модулю 2 , ИЛИ, И (везде побитовое, выход на АЛУ)).**

<img src="./media/image32.png" style="width:6.8842in;height:0.50595in" />

**Операции SLL, SRL, SRA (сдвиг налево, сдвиг направо, арифметический сдвиг направо на B позиций).**

<img src="./media/image33.png" style="width:6.9003in;height:0.5in" />

**Операция SLTS (беззнаковое сравнение A \< B).**

<img src="./media/image34.png" style="width:6.94048in;height:0.80827in" />

Беззнаковое оно, так-как не работает на отрицательных числах (ниже будет пример).

<img src="./media/image35.png" style="width:6.95818in;height:0.79167in" />

**Тест флага C для АЛУ.**

**Операции EQ, NE (A == B, A!= B, в, если выражение верно, то выводить 1)**

<img src="./media/image36.png" style="width:6.86823in;height:0.81667in" />

**Операции LTS, GES (знаковое сравнение “меньше”, “больше или равно”).**

<img src="./media/image37.png" style="width:6.86107in;height:0.72778in" />

**Операции LTU, GEU.**

<img src="./media/image38.png" style="width:6.83431in;height:0.61458in" />

**Про реализацию знакового компаратора (необязательное дополнение).**

Пускай у нас есть сравниватель (операция “меньше”) для беззнаковых десятичных чисел, необходимо реализовать данную операцию для знаковых десятичных чисел (потому как встроенная операция для беззнаковых).

Реализуем данную операцию путем вычитания из A числа B, результат записав в S (S = A-B). Рассмотрим теперь ситуации, когда S \< 0 (то есть, A \< B).

**Когда A \< 0 (знаковый бит = 1), B \> 0 (знаковый бит = 0).**

$$Учтем\\данное\\условие\\выражением\\A\lbrack 31\rbrack\\\overline{B\lbrack 31\rbrack}$$

**Когда A \> 0 (знаковый бит = 0), B \> 0 (знаковый бит = 0), S \< 0 (знаковый бит = 1)**

$$Учтем\\данное\\условие\\выражением\\\overline{A\lbrack 31\rbrack}\\\overline{B\lbrack 31\rbrack}\\ S\lbrack 31\rbrack$$

**Когда A \< 0 (знаковый бит = 1), B \< 0 (знаковый бит = 1), S \> 0 (знаковый бит = 0)**

$$Учтем\\данное\\условие\\выражением\\A\lbrack 31\rbrack\\ B\lbrack 31\rbrack\\\overline{S\lbrack 31\rbrack\rbrack}$$

В итоге, получим выражение для знакового сравнения:

$$comp\_{zn\\A \< B} = A\lbrack 31\rbrack\\\overline{B\lbrack 31\rbrack}\\\left| \\\overline{A\lbrack 31\rbrack}\\\overline{B\lbrack 31\rbrack}\\ S\lbrack 31\rbrack\\ \right|\\A\lbrack 31\rbrack\\ B\lbrack 31\rbrack\\ S\lbrack 31\rbrack\\$$

**Код на Verilog, описывающий компаратор знакового сравнения “меньше”.**

<img src="./media/image39.png" style="width:6.62639in;height:1.50758in" />

**RTL схема знакового компаратора “A меньше B”**

<img src="./media/image40.png" style="width:6.35651in;height:1.75758in" />

**Тест знакового компаратора.**

<img src="./media/image41.png" style="width:6.42424in;height:0.66723in" />

Таким образом, у нас есть встроенный компаратор в Verilog, который реализует беззнаковое “меньше” и сейчас мы описали компаратор на Verilog, который выполняет такую же операцию “меньше”, но уже с знаковыми числами. Операцию “равно” будем использовать встроенную в Verilog, а операцию “больше” реализуем как “меньше”, но с другими входными данными (A \> B это же B \< A).

# Лекция 2. Регистровый файл.

**Вступление**

В Харис-Харисе мне больше всего не нравится его резкий переход от средней цифры (триггеров, мультиплексоров, дешифраторов) к высшей цифре (регистровый файл, АЛУ, расширитель знака и тд). В данной небольшой статье поговорим мы про регистровый файл (по факту, встроенная быстрая память процессора) и его устройство.

**Концепция регистрового файла**

Итак, нам надо сделать вот такую штуковину (упрощенный регистровый файл):

<img src="./media/image42.png" style="width:1.70833in;height:1.68296in" />

**Как она должна работать:**

По управляющей шине мы выбираем номер ячейки памяти, значение с которой мы хотим вывести на выход (соответственно, вход upr_1 управляет out_1, а вход upr_2 управляет out_2)

Вход upr_in задает нам ячейку памяти, в которую надо записывать информацию из data.

Запись в ячейку памяти и ее считывание будет по фронту clk из 0 в 1

**Пример регистрового файла и его работы:**

Давайте сделаем регистровый файл на 32 однобитные ячейки. Тогда, в 3 управляющих шинах (upr_1,upr_2,upr_in) будет по 5 проводов. Так-как ячейки однобитные, то data и out_1, out_2 будут содержать в себе 1 провод.

<img src="./media/image43.png" style="width:1.71667in;height:1.77925in" />

**Запись информации**

<img src="./media/image44.png" style="width:4.45778in;height:0.825in" />

<img src="./media/image45.png" style="width:4.60176in;height:1.31818in" />

Как мы видим, идет запись “1” по clk в 3 ячейку памяти, “0” по clk в 11 ячейку памяти и “1” по clk в 30 ячейку памяти.

**Считывание информации с ячеек памяти**

<img src="./media/image46.png" style="width:3.02158in;height:1.37778in" />

Давайте найдем значение на выходах после 3 event (3 переходов clk с 0 в 1)

$$event\_{1};\\\\\\out\_{1} = память\_{3} = \text{"1"},\\out\_{2} = память\_{11} = "0"$$

$$event\_{2};\\\\\\out\_{1} = память\_{6} = \text{"0"},\\out\_{2} = память\_{3} = "1"$$

$$event\_{3};\\\\\\out\_{1} = память\_{30} = \text{"1"},\\out\_{2} = память\_{13} = "0"$$

**Пример работы регистрового файла (WE = 1 – запись с data в ячейку номером upr_in разрешена)**

<img src="./media/image47.png" style="width:6.49653in;height:1.16597in" />

Ну что, работать с ним мы научились более-менее (точнее, поняли очевидность работы с ним), давайте теперь его соберем из триггеров (4 ячейки памяти, каждая ячейка содержит 1 бит).

**Построение 4-битного регистрового файла на D-триггерах.**

Хоть тут и будет построен только 4-битный регистровый ф+айл c 1 выходом, у которого 1-битная ячейка памяти, но принцип построения 32-битного регистра, у которого 32-битная ячейка памяти будет таким же.

Ну что, давайте строить схему

**Основа – 4 D-триггера с общим clk и in**

<img src="./media/image48.png" style="width:3.28333in;height:3.95427in" />

**Выбор ячейки для записи будет осуществляться дешифратором на сигналы Load. Также, пронумеруем ячейки памяти**

<img src="./media/image49.png" style="width:3.40923in;height:3.35in" />

Ну что, вот мы реализовали запись в наш регистровый файл (по управляющей шине приходит 1 на выбранный триггер, и он записывает это состояние), давайте реализуем считывание.

Для считывания будем применять описанные выше буферы с 3 состояниями, которыми управлять будем с помощью дешифратора (позднее я узнал, что для выхода RF предпочтительнее мультиплексор вместо буферов).

**Реализация считывания:**

<img src="./media/image50.png" style="width:6.8246in;height:3.99167in" />

Таким образом, нами был реализован вот такой вот упрощенный регистровый файл:

<img src="./media/image51.png" style="width:2.33333in;height:2.57179in" />

**Описание на Verilog регистрового файла вручную (не через встроенную ячейку памяти).**

Способ описания на Verilog, представленный ниже, является несколько избыточным (потому как регистровый файл можно строчек на 20 кода реализовать с помощью встроенной синхронной ячейки памяти, но методически верный (если я уж наговорил красивой абстрактной теории про реализацию RF через триггеры, которыми управляют дешифраторы, то хотелось бы данную теорию увидеть в практической реализации и протестировать). Сделаем, для простоты и компактности RF всего-то на 4 бита.

План реализации регистрового файла:

1)  D триггер с сигналом Load

2)  буферы с 3 состояниями для выходов регистрового файла

3)  Дешифратор DX2

4)  Все соединяем и делаем Write Enable (WE)

5)  Тестируем

**D-триггер с сигналом Load**

По смыслу, если Load = 1, то запись в триггер разрешена (out = data), если Load = 0, то запись в триггер запрещена (out = out). Тогда, мы можем записать логическое выражение для out через data и Load:

$$out = data\\ Load\\|\\out\\\overline{Load}$$

Опишем данное устройство на Verilog:

**Код на Verilog**

<img src="./media/image52.png" style="width:2.68823in;height:1.55128in" />

**Схема**

<img src="./media/image53.png" style="width:5.16347in;height:1.29487in" />

**  
**

**Буфер с 3 состояниями**

Вместо буферов с 3 состоянием можно было бы воспользоваться просто мультиплексором, но я решил использовать их.

**Код на Verilog.**

<img src="./media/image54.png" style="width:3.91072in;height:1.54167in" />

**RTL схема.**

<img src="./media/image55.png" style="width:3.54167in;height:2.09068in" />

**Дешифратор DX2 (c enable и без enable).**

Раз уж решил описывать каждый модуль, то и DX2 оставлю тут.

**Код на Verilog**

<img src="./media/image56.png" style="width:1.95833in;height:1.87984in" />

<img src="./media/image57.png" style="width:3.11926in;height:1.63333in" />

**Схема регистрового файла без WE**

<img src="./media/image58.png" style="width:4.86667in;height:4.01023in" />

Для реализации сигнала Write-Enable просто поставим вместо обычного входного дешифратора дешифратор с enable (тогда при WE = 0 он выдает все 0 на выходе и ячейки памяти не будут активными для записи)

<img src="./media/image59.png" style="width:4.91667in;height:4.34958in" />

**Код на Verilog.**

<img src="./media/image60.png" style="width:2.25838in;height:9.23718in" />

**  
**

**Схема регистрового файла с WE.**

<img src="./media/image59.png" style="width:5.2123in;height:4.61111in" />

**Тестирование регистрового файла.**

<img src="./media/image61.png" style="width:6.49653in;height:1.24931in" />

<img src="./media/image62.png" style="width:6.49514in;height:1.18264in" />

<img src="./media/image63.png" style="width:6.49653in;height:1.16597in" />

**Регистровый файл через встроенную ячейку памяти на Verilog (32 ячейки, 32 бита каждая, в нулевой ячейке всегда 0).**

Данный способ куда более быстрый и генерирует просто готовый регистровый файл, именно данным способом обычно быстро описывают Register File как отдельный блок при проектировании процессора

<img src="./media/image64.png" style="width:2.97778in;height:2.78037in" />

<img src="./media/image65.png" style="width:3.60624in;height:3.91667in" />

**Заключение**

В данной статье была разобрана тривиальность как применения регистрового файла, так и его устройства (Д-триггеры и 2 дешифратора), чего, увы, нет в том же Харис-Харисе, из-за чего я сильно тупил над данной темой.

# Лекция 3. Немного про память команд.

**Вступление**

В данной небольшой заметке хотел бы затронуть такой примитив высшей цифровой схемотехники как память команд (играет роль хранителя прошивки для процессора). По сути, это просто постоянная память (ROM), которая по управляющему входу задает выход (это не всегда так, но в довольно простых процессорах данное утверждение верно (а в более сложных структурах иногда эту память заменяют на аналог регистрового файла с некоторыми нюансами).

**Про схему памяти команд**

Как мы поняли ранее в вступлении, память команд – постоянная память (ТЕ ROM, например, Flash-память), так что реализовывать будем ее с “волшебными” ячейками памяти и рассмотрим, собственно, саму организацию ROM.

**ROM с 4 32-битными ячейками памяти**

Разумеется, на выход можно было бы поставить MUX, но в микросхемах памяти предпочитают использовать буферы с 3 состоянием (опять-таки, позднее автор узнал, что для малых элементов памяти мультиплексор предпочтительнее. Про то, как реализуются сами ячейки памяти, мы не думаем — это не наш уровень абстракции.

<img src="./media/image66.png" style="width:2.56091in;height:2.19167in" />

Ну что, абстрактными красивыми словами поговорили, давайте теперь напишем код на Verilog и посмотрим, во что он синтезируется.

**Код на Verilog**

<img src="./media/image67.png" style="width:3.872in;height:1.575in" />

**Схема**

<img src="./media/image68.png" style="width:2.98333in;height:1.39161in" />

Данная строчка просто задает значения для памяти (которые лежат в текстовике)

<img src="./media/image69.png" style="width:2.96667in;height:0.2187in" />

**Содержимое текстовика (памяти команд)**

<img src="./media/image70.png" style="width:2.20455in;height:1.02879in" />

**Тестирование памяти команд.**

<img src="./media/image71.png" style="width:6.49653in;height:0.33333in" />

<img src="./media/image72.png" style="width:6.49167in;height:0.325in" />

<img src="./media/image73.png" style="width:6.49167in;height:0.275in" />

Разумеется, можно вбивать числа и в 16-ричной системе в текстовик, в коде же вместо буковки b (binary) надо будет поставить буковку h (hexadecimal).

Как мы видим, ничего особо не поменялось.

<img src="./media/image74.png" style="width:2.37121in;height:1.43515in" />

**Содержимое текстовика (памяти команд).**

<img src="./media/image75.png" style="width:0.7803in;height:0.83492in" />

**Тестирование памяти команд**

<img src="./media/image76.png" style="width:6.49167in;height:0.34167in" />

# Лекция 4. Простейший процессор.

**Введение**

Автор в данной статье расскажет про весьма сильно упрощенный процессор “Кобра”, архитектура которого что-то около RISC-V, а методически он весьма неплохо показывает устройство процессора и принцип его работы (мне понравилось, потому как сразу в лицо кидать декодер инструкций, конвейеры, параллелизм и тд такое себе). Если же добавить немного спойлеров из следующих лекций, то данный процессор функционально – это RISC-V, реализующий I_1, B, R.

**Про микроархитектуру процессора.**

При рассказе про различные микроархитектуры есть 2 разных подхода: нарисовать картинку красивую и потом объяснять, что она делает, или же поставить создание процессора/блока процессора в качестве задачи и вместе с читателем решать ее. Я пойду этим путем, и построю архитектуру процессора из того, что он должен делать.

При таком подходе реализуются сначала куски архитектуры, которые потом будут соединяться между собой (но это потом, а сейчас давайте не сильно задумываться про то, откуда мы берем различные управляющие сигналы и константы)

1)Он должен уметь перескакивать с 1 строчки программы (содержания памяти команд) на произвольную другую по некоему условию, а если нет, то просто идти сверху вниз (аппаратно реализованные циклы и if-else)

Реализуем сначала аппаратно возможность перескакивать на разные инструкции с помощью мультиплексора.

<img src="./media/image77.png" style="width:2.52273in;height:2.63113in" />

Также, отложим у себя в голове, что надо где-то завести провод, который будет отвечать за переключение мультиплексора (назовем данный провод условным, так-как он будет отвечать за то, работает ли чтение программы в типичном режиме, или же мы перескакиваем куда-то вверх или вниз по выполнению условия).

2)Он должен делать какие-то вычисления и куда-то результаты вычислений складывать, то есть надо АЛУ и память (в качестве которой будет выступать регистровый файл).

<img src="./media/image78.png" style="width:3.60359in;height:1.78846in" />

На рисунке выше изображена условная ситуация, хотелось бы записывать данные в регистровый файл не только с АЛУ, но также константу и с внешних проводов (это вход SW)

Так что более-менее адекватно будет выглядеть такая конфигурация:

<img src="./media/image79.png" style="width:3.61538in;height:1.89224in" />

Разумеется, сюда можно добавить еще как минимум 1 вход (например, константный 0), но это уже на усмотрение читателя.

3)Не будем также забывать о том, что нам нужен некий индикатор в АЛУ, например, сравнения 2 чисел, который я назову C (да, тот самый флаг сравнения).

<img src="./media/image80.png" style="width:3.95347in;height:1.84543in" />

4)Надо откуда-то брать константу, предлагается первые 8 бит команды отдать под константу, но, так-как мы использовали 32-битное представление константы выше, то нам надо расширить константу с 8 бит до 32 (и сохранить знак, так-как константа может быть отрицательным числом).

Решается это весьма просто: мы просто припаиваем 24 провода к 7 (считаем с 0 провода), возможно поставив буфер для более быстрой перезарядки 25 проводов 1 выходом. Таким образом и получается 32-битная константа с сохранением знака.

Данное действие выполняет блок SE – знаковое расширение

<img src="./media/image81.png" style="width:2.125in;height:0.24296in" />

5)Также, надо какие-то биты в команде отдать и под управление переходами в программе (если равен единице бит безусловного перехода, то у нас независимо от результата на АЛУ счетчик должен измениться на константу), а если равен единице бит условного перехода, то уже скачок на константу будет только если на АЛУ индикатор C = 1

Таким образом, получаем некое разбиение 32-битной команды:

<img src="./media/image82.png" style="width:6.68822in;height:0.49167in" />

**Что нового относительно прошлых лекций:**

Разумеется, можно было бы разбить и по-другому, но так будет более-менее близко к реальному процессору.

B – бит безусловного перехода (если он 1, то, например, на 3 инструкции наверх (если константа равна -3)

C – бит условного перехода (если он 1 и C на АЛУ 1, то у нас, опять-таки, на 3 инструкции наверх (const = -3)

WE – записываем/не записываем результат АЛУ в регистровый файл

WS – управление входом в регистровый файл (что записываем: константу, выход АЛУ, с внешних источников?)

Остальные биты инструкции отвечают за выбором операции на АЛУ, за тем, какую ячейку памяти вывести на каждый из 2 выходов регистрового файла, в какую ячейку регистрового файла записываем, 8 первых бит - константа.

**Соединяем блоки**

Далее мы просто берем и различные провода из прошивки (памяти команд) присоединяем к регистровому файлу, АЛУ, мультиплексорам и тд:

<img src="./media/image83.png" style="width:6.76542in;height:2.88333in" />

Читатель сам, при желании, может расставить по разбиению команды номера проводов, которые идут от памяти инструкций к логике.

Мы же сейчас займемся последним штришком: будем реализовывать условный и безусловный перенос. Достигается это весьма просто : ставим И между C и C_ALU, а на вход upr_mux подаем B ИЛИ (C и C_ALU) (что полностью удовлетворяет требованиям условного и безусловного перехода.

<img src="./media/image84.png" style="width:6.49167in;height:3.40833in" />

Вот и все, программируемое устройство, весьма сильно напоминающее процессор готово!

Далее пойдет уже мой код на Verilog в котором я его описываю:

**Мультиплексор на входе в регистровый файл:**

<img src="./media/image85.png" style="width:2.13095in;height:1.97156in" />

**Регистровый файл:**

<img src="./media/image86.png" style="width:3.43452in;height:2.78904in" />

**Модули АЛУ (кроме знакового компаратора, но он в конце статьи есть)**

<img src="./media/image28.png" style="width:1.69697in;height:1.13131in" />

<img src="./media/image29.png" style="width:1.73485in;height:1.00197in" />

<img src="./media/image30.png" style="width:1.8447in;height:0.98485in" />

**  
**

**АЛУ (заметьте, оно больше процессора)**

<img src="./media/image87.png" style="width:3.13315in;height:9.30303in" />

**Кобра, описание на Verilog:**

<img src="./media/image88.png" style="width:3.85839in;height:9.62879in" />

**RTL схема Cobra:**

<img src="./media/image89.png" style="width:7.87183in;height:1.7197in" />

**Вывод**

Мы теоретически разобрали простейший недопроцессор и даже описали его на Verilog и посмотрели, во что он синтезируется (а еще поняли, что процессор = очевидная штуковина). Да, для реального процессора это примерно скелет, нету даже элементарного декодера инструкций, но как ступенька для развития вполне себе подходит.

**Дополнение: компаратор знакового сравнения “меньше” (к АЛУ).**

<img src="./media/image39.png" style="width:6.62639in;height:1.50758in" />

**RTL схема знакового компаратора “A меньше B”**

<img src="./media/image40.png" style="width:6.35651in;height:1.75758in" />

#  Лекция 5. Прошивка “Cobra”

**Введение**

В данной статье мы немного поиграемся с написанным ранее процессором, прошивая его разными способами.

**Операция на АЛУ над регистрами RA1 и RA2, результат записывается в WA**

<img src="./media/image90.png" style="width:4.52083in;height:0.55733in" />

**Загрузка константы в регистр WA**

<img src="./media/image91.png" style="width:4.47447in;height:0.64062in" />

**Пример 1. Найдем сумму 7 и 8. Номер операции ADD (ALU_OP = 0)**

<img src="./media/image92.png" style="width:1.80983in;height:0.17424in" />

**Код на Verilog, который отвечает за то, что будет загружено в регистровый файл (upr_data = WS).**

<img src="./media/image93.png" style="width:2.69788in;height:0.9697in" />

**Строчка 1. Загрузка 7 в регистр 1**

00 1 00 0000 00000 00000 00001 00000111

> 
> 00000111<sub>2</sub> = 7 = *к**о**н**с**т**а**н**т**а*, *к**о**т**о**р**у**ю* *м**ы* *з**а**г**р**у**ж**а**е**м*
>
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

**Строчка 2. Загрузка 8 в регистр 2**

00 1 00 0000 00000 00000 00010 00001000

> 
> 00001000<sub>2</sub> = 8 = *к**о**н**с**т**а**н**т**а*, *к**о**т**о**р**у**ю* *м**ы* *з**а**г**р**у**ж**а**е**м*
>
> 00010<sub>2</sub> = 2 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

*<span class="mark">  
</span>*

**Строчка 3. Загрузка в 3 регистр суммы чисел из 1 и 2 регистра.**

00 1 10 0000 00010 00001 00011 00000000

> 
> 10<sub>2</sub> = 2 − *н**а* *в**х**о**д* *р**е**г**и**с**т**р**о**в**о**г**о* *ф**а**й**л**а* *п**о**д**а**е**т**с**я* *о**п**е**р**а**ц**и**я* *с* *А**Л**У*
>
> 0000<sub>2</sub> = 0 − *н**о**м**е**р* *о**п**е**р**а**ц**и**и* *н**а* *А**Л**У*
>
> 00001<sub>2</sub> = 1 − *с* *э**т**о**й* *я**ч**е**й**к**и* *п**а**м**я**т**и* *б**е**р**е**м* *R**A*2
>
> 00010<sub>2</sub> = 2 − *с* *э**т**о**й* *я**ч**е**й**к**и* *п**а**м**я**т**и* *б**е**р**е**м* *R**A*1
>
> 00011<sub>2</sub> = 3 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *р**е**з**у**л**ь**т**а**т* *о**п**е**р**а**ц**и**и* *н**а* *А**Л**У*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

**Строчка 4. Выводим значение с 3 ячейки регистрового файла (получаем результат)**

00 0 00 0000 00011 00000 00000 00000000

00011<sub>2</sub> = 3 − *в**ы**в**о**д**и**м* *з**н**а**ч**е**н**и**е* *с* 3 *я**ч**е**й**к**и* , *т**к* *с**н**и**м**а**е**м* *д**а**н**н**ы**е*  *с* *в**ы**х**о**д**а* 1 *R**F* 

**Итоговая прошивка:**

00100000000000000000000100000111

00100000000000000000001000001000

00110000000010000010001100000000

00000000000011000000000000000000

**То, что должно быть по clk:**

1)  Загрузка 7 в регистр 1, на выходе RF (RA1) будет 0 ячейка, соответственно, покажет 0.

2)  Загрузка 8 в регистр 2, на выходе RF (RA1) будет 0 ячейка, соответственно, покажет 0.

3)  Загрузка суммы из 1 и 2 регистра в 3 регистр, (RA1 = 1), на выходе RF будет значение в 1 ячейке (то есть 8)

4)  Вывод результата суммы, что записана в 3 ячейке (RA1 = 3), на выходе RF будет результат суммы 7 и 8 = 15

Далее же PC идет +1 и в IM есть только 32’b0 строчки, поэтому регистровый файл выводит значение с 0 ячейки (то есть 0)

**Результат симуляции cobra с нашей прошивкой.**

<img src="./media/image94.png" style="width:6.49514in;height:0.44306in" />

Как читатель видит, вышло ровно так, как и предполагалось.

**Пример 2. Найдем 32-64**

<img src="./media/image95.png" style="width:1.91668in;height:0.17424in" />

<img src="./media/image96.png" style="width:1.97577in;height:0.16667in" />

**  
**

**Строчка 1. Загрузка 32 в регистр 1**

00 1 00 0000 00000 00000 00001 00100000

> 
> 00100000<sub>2</sub> = 32 = *к**о**н**с**т**а**н**т**а*, *к**о**т**о**р**у**ю* *м**ы* *з**а**г**р**у**ж**а**е**м*
>
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

**Строчка 2. Загрузка 64 в регистр 2**

00 1 00 0000 00000 00000 00010 01000000

> 
> 01000000<sub>2</sub> = 64 = *к**о**н**с**т**а**н**т**а*, *к**о**т**о**р**у**ю* *м**ы* *з**а**г**р**у**ж**а**е**м*
>
> 00010<sub>2</sub> = 2 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

**Строчка 3. Загрузка в 3 регистр разницы чисел из 1 и 2 регистра.**

00 1 10 0001 00001 00010 00011 00000000

> 
> 10<sub>2</sub> = 2 − *н**а* *в**х**о**д* *р**е**г**и**с**т**р**о**в**о**г**о* *ф**а**й**л**а* *п**о**д**а**е**т**с**я* *о**п**е**р**а**ц**и**я* *с* *А**Л**У*
>
> 0001<sub>2</sub> = 1 − *н**о**м**е**р* *о**п**е**р**а**ц**и**и* *н**а* *А**Л**У*
>
> 00001<sub>2</sub> = 1 − *с* *э**т**о**й* *я**ч**е**й**к**и* *п**а**м**я**т**и* *б**е**р**е**м* *R**A*2
>
> 00010<sub>2</sub> = 2 − *с* *э**т**о**й* *я**ч**е**й**к**и* *п**а**м**я**т**и* *б**е**р**е**м* *R**A*1
>
> 00011<sub>2</sub> = 3 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *р**е**з**у**л**ь**т**а**т* *о**п**е**р**а**ц**и**и* *н**а* *А**Л**У*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

**Строчка 4. Выводим значение с 3 ячейки регистрового файла (получаем результат)**

00 0 00 0000 00011 00000 00000 00000000

00011<sub>2</sub> = 3 − *в**ы**в**о**д**и**м* *з**н**а**ч**е**н**и**е* *с* 3 *я**ч**е**й**к**и* , *т**к* *с**н**и**м**а**е**м* *д**а**н**н**ы**е*  *с* *в**ы**х**о**д**а* 1 *R**F* 

**Итоговая прошивка:**

00100000000000000000000100100000

00100000000000000000001001000000

00110000100001000100001100000000

00000000000011000000000000000000

**То, что должно быть по clk:**

1)  Загрузка 32 в регистр 1, на выходе RF (RA1) будет 0 ячейка, соответственно, покажет 0.

2)  Загрузка 64 в регистр 2, на выходе RF (RA1) будет 0 ячейка, соответственно, покажет 0.

3)  Загрузка разницы (RA1-RA2) в 3 регистр, (RA1 = 1), на выходе RF будет значение в 1 ячейке (то есть 32)

4)  Вывод результата разницы, что записана в 3 ячейке (RA1 = 3), на выходе RF будет результат 32-64= -32

Далее же PC идет +1 и в IM есть только 32’b0 строчки, поэтому регистровый файл выводит значение с 0 ячейки (то есть 0)

**Результат симуляции cobra с нашей прошивкой.**

<img src="./media/image97.png" style="width:5.50595in;height:0.37201in" />

**Поиграемся теперь с условным переносом (бит C).**

В общем-то, условный перенос просто заставляет счетчик, который идеи по программе прибавлять не 1, а значение, заданное в константе, таким образом можно как идти наверх по программе, так и вниз, реализуя при этом циклы и операции if/else.

<img src="./media/image98.png" style="width:3.32143in;height:0.76895in" />

**Код на Verilog, описывающий PC (c – флаг сравнения АЛУ).**

<img src="./media/image99.png" style="width:2.59524in;height:0.12358in" />

<img src="./media/image100.png" style="width:1.35714in;height:0.65801in" />

**Пример 3. Умножение 7 на 3 через константы.**

**Строчка 1. Загрузка 7 в регистр 1**

00 1 00 0000 00000 00000 00001 00000111

> 
> 00000111<sub>2</sub> = 7 = *к**о**н**с**т**а**н**т**а*, *к**о**т**о**р**у**ю* *м**ы* *з**а**г**р**у**ж**а**е**м*
>
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

**Строчка 2. Загрузка 3 в регистр 2**

00 1 00 0000 00000 00000 00010 00000011

> 
> 00000011<sub>2</sub> = 3 = *к**о**н**с**т**а**н**т**а*, *к**о**т**о**р**у**ю* *м**ы* *з**а**г**р**у**ж**а**е**м*
>
> 00010<sub>2</sub> = 2 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

**Строчка 3. Загрузка 1 в регистр 4**

00 1 00 0000 00000 00000 00100 00000001

> 
> 00000001<sub>2</sub> = 1 = *к**о**н**с**т**а**н**т**а*, *к**о**т**о**р**у**ю* *м**ы* *з**а**г**р**у**ж**а**е**м*
>
> 00100<sub>2</sub> = 4 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

*<span class="mark">  
</span>*

**Строчка 4. Сложение значения из 1 регистра (число 7) c 3 ячейкой и запись в 3 ячейку.**

00 1 10 0000 00001 00011 00011 00000000

> 
> 10<sub>2</sub> = 2 − *н**а* *в**х**о**д* *р**е**г**и**с**т**р**о**в**о**г**о* *ф**а**й**л**а* *п**о**д**а**е**т**с**я* *о**п**е**р**а**ц**и**я* *с* *А**Л**У*
>
> 0000<sub>2</sub> = 0 − *н**о**м**е**р* *о**п**е**р**а**ц**и**и* *н**а* *А**Л**У*
>
> 00011<sub>2</sub> = 3 − *с* *э**т**о**й* *я**ч**е**й**к**и* *п**а**м**я**т**и* *б**е**р**е**м* *R**A*2
>
> 00001<sub>2</sub> = 1 − *с* *э**т**о**й* *я**ч**е**й**к**и* *п**а**м**я**т**и* *б**е**р**е**м* *R**A*1
>
> 00011<sub>2</sub> = 3 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *р**е**з**у**л**ь**т**а**т* *о**п**е**р**а**ц**и**и* *н**а* *А**Л**У*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

**Строчка 5. Вычитание из числа в 2 ячейке (играет роль счетчика) значение из 4 ячейки (число 1) и записываем в 2 ячейку.**

00 1 10 0001 00010 00100 00010 00000000

> 
> 10<sub>2</sub> = 2 − *н**а* *в**х**о**д* *р**е**г**и**с**т**р**о**в**о**г**о* *ф**а**й**л**а* *п**о**д**а**е**т**с**я* *о**п**е**р**а**ц**и**я* *с* *А**Л**У*
>
> 0001<sub>2</sub> = 1 − *н**о**м**е**р* *о**п**е**р**а**ц**и**и* *н**а* *А**Л**У*
>
> 00100<sub>2</sub> = 4 − *с* *э**т**о**й* *я**ч**е**й**к**и* *п**а**м**я**т**и* *б**е**р**е**м* *R**A*2
>
> 00010<sub>2</sub> = 2 − *с* *э**т**о**й* *я**ч**е**й**к**и* *п**а**м**я**т**и* *б**е**р**е**м* *R**A*1
>
> 00010<sub>2</sub> = 2 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *р**е**з**у**л**ь**т**а**т* *о**п**е**р**а**ц**и**и* *н**а* *А**Л**У*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

**Строчка 6. Выводим значение с 3 ячейки регистрового файла (получаем результат)**

00 0 00 0000 00011 00000 00000 00000000

00011<sub>2</sub> = 3 − *в**ы**в**о**д**и**м* *з**н**а**ч**е**н**и**е* *с* 3 *я**ч**е**й**к**и* (*ч**т**о**б**ы* *м**ы* *н**а* *д**и**а**г**р**а**м**м**е* *у**в**и**д**е**л**и*) 

**Строчка 7. Если значение на больше 0, то идти наверх на 3 шага (PC = PC + (-3));**

<img src="./media/image101.png" style="width:1.47009in;height:0.11111in" />

<img src="./media/image102.png" style="width:2.20556in;height:0.11867in" />

<img src="./media/image98.png" style="width:4.34194in;height:1.00521in" />

**Идея: счетчик больше 0 это тоже самое, что и 0 меньше счетчика.**

01 0 00 1100 00000 00010 00000 11111101

> 
> 11111101<sub>2</sub>=  − 3 − *ч**и**с**л**о*, *к**о**т**о**р**о**е* *п**р**и**б**а**в**и**т**с**я* *к* *P**C*, *е**с**л**и* *у**с**л**о**в**и**е* *б**у**д**е**т* *в**е**р**н**о*.
>
> 1100<sub>2</sub> = 12 − *н**о**м**е**р* *о**п**е**р**а**ц**и**и* *н**а* *А**Л**У*
>
> 00000<sub>2</sub> = 0 − *с* *э**т**о**й* *я**ч**е**к**и* *б**е**р**е**м* A = 32<sup>′</sup>*b*0
>
> 00010<sub>2</sub> = 2 − *с* *э**т**о**й* *я**ч**е**й**к**и* *б**е**р**е**м* *з**н**а**ч**е**н**и**е* *с**ч**е**т**ч**и**к**а* = *B*
>
> 1 − *и**д**е**т* *у**с**л**о**в**н**ы**й* *п**е**р**е**х**о**д* (*е**с**л**и* *у**с**л**о**в**и**е* *в**е**р**н**о*, *т**о* *P**C* = *P**C* + *c**o**n**s**t* = *P**C* − 3)

*  
*

**Итоговая прошивка:**

00100000000000000000000100000111

00100000000000000000001000000011

00100000000000000000010000000001

00110000000001000110001100000000

00110000100010001000001000000000

00000000000011000000000000000000

01000110000000000100000011111101

**То, что должно быть по clk:**

1)  0, 1, 2 clk – на выходе 0 (так-как идет запись в память)

2)  На 3 clk выдаст 7, так-как оно лежит в регистре 1, к которому обращаются в команде 4.

3)  На 4 clk выдаст значения счетчика (сколько раз надо сложить).

4)  На 5 clk идет вывод значения суммы

5)  Далее, пока счетчик больше 0, переходим к пункту 3 (но сначала выдаем 0, так-как A = 0)

6)  После всего процесса выдаем 0.

**Результат симуляции cobra с нашей прошивкой.**

<img src="./media/image103.png" style="width:6.49444in;height:0.41667in" />

Также, мы можем увеличить значение первой константы, например, до 31 (меняем константу в первой строке).

**Итоговая прошивка:**

00100000000000000000000100011111

00100000000000000000001000000011

00100000000000000000010000000001

00110000000001000110001100000000

00110000100010001000001000000000

00000000000011000000000000000000

01000110000000000100000011111101

**Результат симуляции cobra с нашей прошивкой.**

<img src="./media/image104.png" style="width:6.49514in;height:0.47431in" />

Разумеется, обычно вместо const берут запись значения с внешних выводов SW (switches), но отличаются эти способы лишь тем, откуда в итоге числа попадут в память (регистровый файл) (то есть, отличаться от приведенных будут только первые 2-3 операции).

Для примера давайте рассмотрим теперь программу умножения 7 на 3, но 7 и 3 загружаются с входа SW. На самом деле, отличаться будет только управляющий сигнал на MUX у входа в регистровый файл (из рисунка видно, что надо туда поставить 2 (upr_data = WS = 1)

<img src="./media/image105.png" style="width:5.88028in;height:2.98485in" />

**Описание этого элемента на Verilog в cobra.**

<img src="./media/image106.png" style="width:3.06177in;height:1.07576in" />

В итоге, команда для записи значения с внешних выводов выглядит так:

<img src="./media/image107.png" style="width:4.13021in;height:0.51692in" />

**Строчка 1. Загрузка числа 1 (в SW выставим 7) в регистр 1**

00 1 01 0000 00000 00000 00001 00000000

> 
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 01<sub>2</sub> = 1 − *п**о**к**а**з**ы**в**а**е**т*, *ч**т**о* *з**а**п**и**с**ь* *д**а**н**н**ы**х* *б**у**д**е**т* *с* *S**W*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

**Строчка 2. Загрузка числа 2 (в SW выставим 3) в регистр 2**

00 1 01 0000 00000 00000 00010 00000000

> 
> 00010<sub>2</sub> = 2 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 01<sub>2</sub> = 1 − *п**о**к**а**з**ы**в**а**е**т*, *ч**т**о* *з**а**п**и**с**ь* *д**а**н**н**ы**х* *б**у**д**е**т* *с* *S**W*
>
> 1 − *р**а**з**р**е**ш**а**е**м* *з**а**п**и**с**ь* *в* *р**е**г**и**с**т**р**о**в**ы**й* *ф**а**й**л*

Далее же код будет полностью аналогичен коду с примера 3.

**Итоговая прошивка:**

00101000000000000000000100000000

00101000000000000000001000000000

00100000000000000000010000000001

00110000000001000110001100000000

00110000100010001000001000000000

00000000000011000000000000000000

01000110000000000100000011111101

Результат симуляции данного кода должен быть полностью аналогичен примеру 3.

**Результаты симуляции на cobra с нашей прошивкой.**

<img src="./media/image108.png" style="width:6.4875in;height:0.46181in" />

<img src="./media/image109.png" style="width:6.47917in;height:0.29722in" />

<img src="./media/image110.png" style="width:6.49653in;height:0.41667in" />

<img src="./media/image111.png" style="width:6.48958in;height:0.44792in" />

Но, так-как алгоритм только складывает число (-17) 5 раз, то умножение двух отрицательных чисел он выполнить уже не в состоянии (тут уже алгоритм менять надо)

<img src="./media/image112.png" style="width:6.49653in;height:0.41667in" />

Если же переводить реализованный нами алгоритм в псевдокод, то выйдет:

A = input()

B = input()

C = 1

S = 0 (его не записывал, так-как все ячейки регистрового файла изначально 0)

While (0 \< B):

S = S+A

B = B – C

Print (S)

# Лекция 6. Простейший RISC-V.

**Введение(+GaSoline)**

В данной статье будем считать, что у нас есть Cobra. Жить с коброй под боком довольно некомфортно, поэтому нужно переходить на какой-то более адекватный процессор. Для начала это будет простейший однотактный RISC-V. Попробуем перейти к нему логически от Cobra.

<img src="./media/image82.png" style="width:6.68822in;height:0.49167in" />

Рисунок. 1. Схема кодирования инструкций в кобре \[гитхабМПСУ\]

Вот наша команда для Cobra. В ней всегда есть место для операции на АЛУ, адресов регистров чтения и записи, фиксированный размер константы. Как сделать её лучше? Наша цель – увеличить быстродействие схемы. Значит, нужно:

1.  увеличить ёмкость одной операции;

2.  увеличить количество операций, выполняющихся параллельно;

3.  сократить время на одну операцию.

**Часть 1. Инструкции, кодирование, декодирование (+GaSoline)**

Данный раздел статьи будет весьма сильно пересекаться с разделом про декодер, так-как декодер инструкций и есть принципиально основная штуковина, которая отличает простейший RISC-V от Cobra. (by KeK)

Первый недостаток, который можно заметить, — это малая информативность инструкции. Допустим, мы хотим прибавить константу к какому-то регистру. У нас будет 5 неиспользуемых бит поля RA2, поскольку регистр один. Естественно, при этом отдать их под поле константы. Или другой пример – перемещение значения в регистр из памяти. Здесь нам тоже нужен только один регистр. Таким образом, можно увеличить количество инструкций и их ёмкость, если неиспользуемые биты переназначить.

Сразу с этим возникает проблема: как мы будем отличать, что лежит в выделенных битах? Этим занимается отдельный блок, которого в кобре не было, – декодер. Естественно, чем сложнее закодирована инструкция и чем больше их количество, тем больше и сложнее декодер.

Для RISC-V и подобных архитектур написать его довольно несложно, хотя потребуются время и силы, а для x86 его описание может затянуться на месяцы даже при большом желании.

Итак, разделим инструкции на типы. Тип инструкции зашьём в её последние 7 бит и назовём это дело опкодом (opcode), т.е. кодом операции. Далее, выделим первые 7 бит на конкретизацию операции. То есть, здесь мы можем сказать, какую именно инструкцию данного типа мы хотим выполнить. Это поле func7. Аналогично поступим ещё с 3 битами, и их назовём func3. risc-v модульный, а мы делаем пока самую простую его версию, поэтому func7 использоваться в этом смысле практически не будет, а вот func3 есть почти во всех инструкциях. Добавим к этому набору адреса регистров чтения и записи (15 бит), получим суммарно 7+7+3+15=32. После текстового описания давайте ознакомимся с картинкой из мануала к risc-v.

<img src="./media/image113.png" style="width:3.86776in;height:6.7in" alt="rv32i_BIS.png" />

табл. 1. команды RISC-V \[rvdoc\]

Первая табличка – деление инструкций на типы по опкоду. Видно, что неиспользуемые поля, вроде func7 и rs2 (то же, что RA2), заменены более нужной информацией – битами константы imm. Далее перечисляются базовые инструкции из набора RV32I и дополнения Ziscr, их назначение можно рассмотреть позже. Имеет смысл сразу добавить табличку, в которой описано назначение всех этих инструкций.

<img src="./media/image114.png" style="width:6.49653in;height:4.08469in" alt="rv32i_summary.png" />

табл. 2. описание инструкций и их запись в ассемблере \[гитхабМПСУ\]

**Часть 2. Получение RISC-V из Cobra (+GaSoline)**

<img src="./media/image84.png" style="width:6.73841in;height:3.53788in" />

Выше нарисована схема Cobra, которую мы собрали в прошлых статьях. По сути, если в АЛУ есть все операции из таблички (и они закодированы так как надо), то RISV-V можно построить, просто приделав декодер инструкций и мультиплексоры на каждый из выходов регистрового файла и чуток модифицировав PC, чем мы и займемся в данном разделе.

**Модификации PC**

Из-за того, что у нас константа закодирована по-разному в разных типах команд (это неудобство, которым мы платим за большую эффективность процессора), то у нас на PC необходимо поставить возможность перехода по константам разных типов (в зависимости от типа инструкции), то есть, появится несколько лишних мультиплексоров. Задачей определения типов команд и расстановкой всех управляющих сигналов у нас займется декодер, так что будем забивать голову этим уже в следующей статье.

**Структурная схема счетчика после добавления нескольких видов констант**

<img src="./media/image115.png" style="width:3.29861in;height:3.46084in" />

Более важными отличиями являются смена типа адресации и схемная реализация команды jalr (PC присваивается значение из регистра RD1 + const_I). Решение проблемы с jalr весьма простое: просто добавим мультиплексор на счетчик и при управляющем сигнале = 0 будем подавать типичное значение, а при управляющем сигнале = 1 подадим значение из регистра1+const_I

**Структурная схема счетчика с поддержкой jalr**

<img src="./media/image116.png" style="width:3.549in;height:3.04861in" />

**Побайтовая адресация в памяти команд**

Также скажем пару слов про побайтовую адресацию в памяти команд. На самом деле, конкретно для памяти команд в вакууме это не имеет какого-то особого смысла именно концептуально, побайтовая адресация важна для памяти данных для работы с отдельными байтами, а на память команд ее налепили просто ради единообразия и стыковки с внешними элементами (тем же программатором) и для поддержки сжатых инструкций (например, 16-битных), где не надо заново переписывать память команд, а просто прибавить не 4 (ниже поясню, почему 4), а 2 (для 16-битных). Если же делать процессор for fun, то заморачиваться с этим пунктом особо не стоит (но все же желательно, если не хотите писать прошивку вручную, а использовать компиляторы, которые уже есть) и можно просто прибавлять 1 (описание памяти команд на Verilog будет другим и 4 на 1 в остальных mux поменять придется)

Откуда же я взял волшебные числа 4 и 2? Все просто: 32-битная команда – это 4 байта, а 16-битная команда – это 2 байта, поэтому для перехода между командами 32-битными надо перескакивать через 4 байта, а 16-битными – через 2 байта.

**Итоговая реализация счетчика (1 заменили на 4).**

<img src="./media/image117.png" style="width:3.07576in;height:2.12593in" />

**Память команд с побитовой адресацией:**

<img src="./media/image118.png" style="width:2.55303in;height:1.63565in" />

**Модификация системы регистровый файл + АЛУ + память**

**Шаг 1. Переставим мультиплексоры**

В Cobra система АЛУ/Регистровый файл была реализована просто и прямолинейно: выходы регистрового файла подаются сразу на АЛУ, а вход мультиплексируется, у нас же будет чуток по-другому: входы АЛУ мультиплексируются, а выход АЛУ идет на регистровый файл (по сути своей это примерно одно и тоже)

**Было:**

<img src="./media/image119.png" style="width:3.71212in;height:1.64983in" />

**Стало (просто переставили мультиплексоры и чуток расширили входы):**

<img src="./media/image120.png" style="width:4.09848in;height:2.03221in" />

Из относительно нового у нас несколько разных констант, также есть возможность на АЛУ работать с PC (это надо для работы с всякими jal, jalr и подобными командами, где нужно сохранить куда-то значение PC или же PC +4 (адрес возврата на строчку памяти команд)).

**Шаг 2. Добавляем Data Memory**

Если внимательно посмотреть на рисунок выше и подумать, то относительно очевидным будет решение просто поставить data memory между регистровым файлом и АЛУ и просто мультиплексировать выход (если надо, то данные идут на data memory, иначе данные идут в регистровый файл). Очевидным же решение я назвал потому, что у нас регистровый файл и память команд играют примерно одинаковую роль.

<img src="./media/image121.png" style="width:4.56061in;height:2.31895in" />

**Шаг 3. Добавляем управлятор к мультиплексорам.**

Выше мы уже собрали вот такой вот процессор, в котором невооружённым взглядом видны торчащие провода управления от мультиплексоров и всякие enable:

<img src="./media/image122.png" style="width:6.54261in;height:2.34849in" />

Теперь нужно реализовать управлятор (декодер инструкций), который по opcode, funct3, funct7 будет выдавать необходимые значения на управляющие входы АЛУ, Data Memory, WE и тд. В данной статье будем считать его волшебной коробочкой, которую подробно (и долго) будем собирать в следующей лекции (то есть, воспользуемся проектирование сверху вниз, когда мы сначала говорим, то волшебная штуковина у нас есть, а потом долго и мучительно ее реализуем).

<img src="./media/image123.png" style="width:6.75462in;height:3.06818in" />

Ну что, все, RISC-V готов, осталось собрать декодер (следующая статья), соединить все блоки между собой (8 лекция, где будет преимущественно описание на Verilog процессора) и можно тестировать будет (код на C перегоняем в ассемблер RISC-V, а его в машинный код).

# Лекция 7. Декодер инструкций RISC-V.

**Большое вступление (на всю страничку).**

Как читатель мог заметить на примере упрощенного процессора Cobra, у нас в инструкции всегда очень много “лишних” проводов, и с их более разумным использованием можно было бы расширить возможности самого процессора.

**Пример операции на АЛУ Cobra, когда 8 бит никак полезно не используются**

<img src="./media/image90.png" style="width:6.62454in;height:0.81667in" />

**Загрузка константы. Не используется 14 бит.**

<img src="./media/image91.png" style="width:6.63531in;height:0.95in" />

То-есть, подводя итог примерам выше, у нас есть неиспользуемые биты в каждом конкретном типе операций, так что весьма разумно сделать так, чтобы инструкции обладали большим полезным содержанием. Авторы RISC-V, скорее всего подумали также и несколько модифицировали команды, сделав не как в Cobra их прямое исполнение (то есть, конкретный бит команды идет напрямую на АЛУ или управляющий мультиплексор регистрового файла), а через посредника, биты команды же играют роль управляющих сигналов мультиплексора, которые с помощью декодера инструкций (нашего посредника) уже “собираются” в новую команду, которая поступит на устройства.

Таким образом, возрастает эффективность команд устройства (например, мы теперь имеем возможность расширить список операций на АЛУ из-за такого варианта кодирования)

**Про кодировку команд, схожесть и отличия с Cobra.**

Главным отличием команд RISC-V от своей упрощенной версии (Cobra) являются поля funct3, funct7, opcode и непостоянство принадлежности битов к своему полю (для некоторых типов команд биты с 7 по 11играют роль rd (upr_in в кодировкеCobra для регистрового файла), а для других являются частью imm (константы). Кстати, в J-типе константа выглядит как монстр Франкенштейна из-за того, что процессор должен поддерживать 8 битные инструкции (поэтому пришлось так нашинковать изначальную команду и собрать из нее константу).

<img src="./media/image124.png" style="width:6.90815in;height:1.60833in" />

Разберем теперь каждое поле по отдельности

**Funct3, funct7.**

Называются так они из-за их размеров (funct3 – 3 бита, funct7 – 7бит). Используются данные поля для выбора команды на АЛУ (практически всегда только func3, func7 уже выступает в роли дополнительных битов).

**Opcode – распределятор ролей.**

Данная штуковина кодирует тип инструкции (а тип инструкции отвечает за то, как именно декодер распределит управляющие биты на все блоки процессора по их видам и за наличие, собственно, самих типов команд).

**Type R (Register/Register), opcode = 7’d51.**

В данном типе операций данные берутся с регистров, производится операция на АЛУ и результат записывается в регистр. Использует регистры для управления регистровым файлом: RS1 (у меня это upr_1), RS2 (у меня это upr_2), rd (у меня это upr_in). Пример команд: ADD (сложение), SUB (вычитание), OR (логическое ИЛИ).

**Type I (Immediate), opcode = 7’d19, 7’d3, 7’d103**

Данный тип инструкций можно назвать регистр-константа (есть регистр, с которого берем данные, есть регистр, в который данные записываем, есть константа, с которой выполняем операции на АЛУ). Пример команд: ADDI (сложение регистра с константой), загрузка данных из памяти, условные переходы. Из нового относительно прошлого типа – константа Imm.

На самом деле, тип Immediate имеет целых 3 opcode, так-как это объединенный тип операции (когда есть 3 типа операций, но выполняют они все примерно одинаковые вещи). Ниже как раз-таки представлено это разделение**.**

<img src="./media/image125.png" style="width:5.18889in;height:1.575in" />

**Type S (Store), opcode = 7’d35**

Данный тип инструкции – запись в память (именно в data memory, а не в регистровый файл). Данный тип инструкций не возвращает результат в регистр (это отличие его от Immediate). Пример команд: SW (запись 32 бит (слова)), SH (запись 16 бит (полуслова)), SB (запись 8 бит (байта))

**Type B (Branch), opcode = 7’d99**

Данный тип инструкций реализует условные переходы (if/else), но в отличие от типа Immediate никуда не записывает данные. По разбивке команды весьма сильно похож на Store, хотя и имеет разный с ним функционал. Примеры команд: BEQ (перейти, если равно), BNE (перейти, если не равно), но imm интерпретируется как шаг перехода (сколько прибавить к счетчику, если команда верна).

**Type U (Upper Immediate), opcode = 7’d23, 7’d55**

В данном типе инструкций 2 opcode по очень простой причине: в команде нет поля funct3, а значит роль мультиплексора выполняет только opcode

Данный тип инструкций работает с старшими битами константы (с 31 по 12), которые мы используем как хотим (используется для формирования 32-битных адресов (LUI) и для прибавления к PC константы, в которой мы задаем только старшие биты (а с 11 по 0 бит записываются 0)).

**Type J (Jump), opcode = 7’d111**

Данный тип инструкций отвечает за переход с сохранением адреса возврата, используется при вызове функций и возврате из них. Константа определяет относительный адрес перехода (сколько надо прибавить к PC, чтобы перейти на нужную нам строчку кода).

**Декодер инструкций как функциональный блок.**

Итак, мы более-менее разобрались с кодировкой инструкции по типам, присвоили им opcode, но ничего не сказали про декодер инструкций (точнее, что в него выходит, а что выходит). Хотелось бы сказать, что в данное устройство входит вся команда, но оказывается можно обойтись лишь “дополнительными битами” по отношению к Cobra (opcode, funct3, funct7), а с остальным разберутся мультиплексоры и выходы декодера.

**Декодер инструкций. Черный провод – вход (funct3, funct7, opcode), синие провода – выходы декодера**

<img src="./media/image126.png" style="width:2.55729in;height:1.47757in" />

**Декодер инструкций в RISC-V (однотактном)**

<img src="./media/image127.png" style="width:6.80632in;height:3.09167in" />

**Реализация декодера инструкций.**

На самом деле, декодер сложен скорее не концептуально, а объемно (150+ строк кода на Verilog), поэтому в данной статье читатель должен набраться терпения и мужества ради чтения страниц так 10 практически однообразных действий.

**Инструкция типа R (Register/Register)**

<img src="./media/image128.png" style="width:6.4875in;height:0.39097in" />

<img src="./media/image129.png" style="width:6.48472in;height:2.54167in" />

Опишем комбинационную схему, которая при opcode = 51 реализует функционал, для типа R, описанный выше.

**Биты srcA и srcB для инструкции типа R**

<img src="./media/image130.png" style="width:2.45833in;height:2.6728in" />

Так-как в данном типе инструкций мы берем данные с регистрового файла и в него же их записываем после результата операции на АЛУ, то <span class="mark">srcA = 2’d0, srcB = 3’d0</span> (смотри картинку выше).

**Биты ws, memi, mwe для инструкции типа R**

<img src="./media/image131.png" style="width:4.32891in;height:2.38333in" />

Так-как данные должны записаться в регистровый файл, то <span class="mark">ws = 0</span> (без записи в память Data Memory), <span class="mark">mwe = 0</span> (еще вырубим Data Memory, чтобы данные не записывала). Выход декодера memi можно сделать произвольным (так-как Data Memory не работает, а memi отвечает за тип операции с памятью (запись числа знакового, запись числа беззнакового, чтение и тд, у нас memi будет 5-битным), поэтому выставим <span class="mark">memi = 5’d0</span>

**Таблица про то, что делает memi в Data Memory**

<img src="./media/image132.png" style="width:6.75142in;height:1.59167in" />

**Бит aop (операция на АЛУ) для инструкции типа R.**

Из-за нашей специальной кодировки АЛУ (смотри 3 АЛУ из статьи про АЛУ) мы получаем весьма простое выражение для его управляющих битов:

*a**o**p* = {*f**u**n**c**t*7\[6 : 5\], *f**u**n**c**t*3} − *ш**и**н**а* *и**з* 2 *п**о**с**л**е**д**н**и**х* *п**р**о**в**о**д**о**в* *f**u**n**c**t*7 *и*  *в**с**е**г**о* *f**u**n**c**t*3 

**Бит rfwe**

<img src="./media/image133.png" style="width:2.39167in;height:2.93121in" />

В операции типа R мы будем записывать данные в регистровый файл, поэтому ставим <span class="mark">rfwe = 1’d1</span>.

**Биты enpc, jal, jalr, b.**

<img src="./media/image117.png" style="width:5.16019in;height:3.56667in" />

Далее весь анализ делается на основе картинки выше.

Бит jal отвечает за безусловный перенос, в операции типа R данного переноса нет, поэтому <span class="mark">jal = 1’d0</span>

Бит enpc отвечает за работу счетчика (счетчик работать должен как обычно), поэтому <span class="mark">enpc = 1’d1</span>

Бит jalr отвечает за работу счетчика в обычном режиме, или же резкий переход на какой-то адрес, в инструкции типа R, как нетрудно догадаться, <span class="mark">jalr = 1’d0</span>

Бит b отвечает за условные переходы, в инструкции типа R такого не происходит, поэтому <span class="mark">b = 1’d0</span>

**Инструкции типа I (Immediate) (opcode =7’d19)**.

<img src="./media/image134.png" style="width:6.64271in;height:0.23333in" />

Опишем комбинационную схему, которая при opcode = 19 реализует функционал, для типа I, описанный выше.

<img src="./media/image135.png" style="width:7.30624in;height:0.75in" />

**  
**

**Биты srcA и srcB для инструкции типа I**

<img src="./media/image130.png" style="width:2.51667in;height:2.73622in" />

Так-как в данном типе инструкций мы берем данные с регистрового файла, с константы и в регистровый файл их записываем после результата операции на АЛУ, то <span class="mark">srcA = 2’d0, srcB = 3’d1</span> (смотри картинку выше).

**Биты ws, memi, mwe для инструкции типа I (opcode – 19)**

<img src="./media/image136.png" style="width:6.09983in;height:3.35833in" />

Так-как данные должны записаться в регистровый файл, то <span class="mark">ws = 0, mwe = 0, memi = 5’d0</span>

**Бит aop (операция на АЛУ) для инструкции типа R.**

Из-за нашей специальной кодировки АЛУ мы получаем:

*a**o**p* = {2<sup>′</sup>*d*0, *f**u**n**c**t*3} 

**Бит rfwe**

<img src="./media/image137.png" style="width:1.96503in;height:2.40833in" />

В операции типа I мы будем записывать данные в регистровый файл, поэтому ставим <span class="mark">rfwe = 1’d1</span>.

**Биты enpc, jal, jalr, b.**

<img src="./media/image138.png" style="width:5.03962in;height:3.48333in" />

Далее весь анализ делается на основе картинки выше.

Бит jal отвечает за безусловный перенос, в операции типа I данного переноса нет, поэтому <span class="mark">jal = 1’d0</span>

Бит enpc отвечает за работу счетчика (счетчик работать должен как обычно), поэтому <span class="mark">enpc = 1’d1</span>

Бит jalr отвечает за работу счетчика в обычном режиме, или же резкий переход на какой-то адрес, в инструкции типа I, как нетрудно догадаться, <span class="mark">jalr = 1’d0</span>

Бит b отвечает за условные переходы, в инструкции типа I такого не происходит, поэтому <span class="mark">b = 1’d0</span>

<span class="mark">  
</span>

**Инструкции типа I (Immediate) (opcode =7’d3)**.

Отличием данного типа инструкций от I с opcode = 19 является работа с памятью

<img src="./media/image139.png" style="width:6.49653in;height:0.5in" />

То-есть, все выходы декодера будут такими же, как и у opcode = 19 кроме битов, отвечающих за работу с памятью.

**Биты ws, memi, mwe для инструкции типа I (opcode =3)**

<img src="./media/image136.png" style="width:6.11497in;height:3.36667in" />

<img src="./media/image132.png" style="width:6.85745in;height:1.61667in" />

Так-как данные должны считаться из памяти и записаться в регистровый файл, то из картинки выше следует, что надо поставить <span class="mark">ws = 1, mwe = 1, Memi\[0\] = 1, Memi\[1\] = 0, Memi\[4:2\] = funct3</span>.

**Инструкции типа I (Immediate) (opcode =7’d103)**.

<img src="./media/image140.png" style="width:6.49514in;height:0.10417in" />

**Биты aop, ws, memi, mwe, rwe, srcA, srcB для инструкции типа I (opcode – 103)**

<img src="./media/image117.png" style="width:5.70273in;height:3.94167in" />

<span class="mark">Mwe = 1’d0, Memi = 5’d0, ws = 1’d0, rfwe = 1’d1, (работаем с регистровым файлом, а не с памятью)</span>

<span class="mark">srcA = 2’d1, srcB = 3’d4, aop = 5’d0 (берем значение с PC и 4, делаем сложение (0 операция на АЛУ) и записываем в RF)</span>

<span class="mark">Jalr = 1’d1 (так-как надо перейти на значение в регистре 1 + константа)</span>

Остальные биты такие же, как и при других opcode инструкции типа I

<span class="mark">  
</span>

**Описание на Verilog декодера, реализующего декодирование инструкций типа R, I**

<img src="./media/image141.png" style="width:4.97222in;height:9.58882in" />

**Реализация инструкций типа S (opcode = 7’d35}.**

Что-ж, самый объемный кусок декодера мы написали, осталось только добить мелочь по типу инструкций S, J, U, B. Так-как читателю (надеюсь) уже относительно понятен алгоритм расставления значений на выходах декодера, то обойдусь минимальными пояснениями.

<img src="./media/image142.png" style="width:6.49653in;height:0.325in" />

<img src="./media/image136.png" style="width:4.85867in;height:2.675in" />

**Очередная табличка про кодировку памяти**

<img src="./media/image132.png" style="width:6.82211in;height:1.60833in" />

<span class="mark">Mwe = 1’d1, Memi = {1’d0,1’d1, 3’df}, ws = 1’d1, rfwe = 1’d0, srcA = 2’d0, srcB = 3’d3, aop = 5’d0 (берем значение с RD1, складываем с константой и получаем адрес, по которому мы записываем значение с RD2 записываем в память, в RF ничего не записываем)</span>

<span class="mark">Jalr = 1’d0, Jal = 1’d0, b = 1’d0, enpc = 1’d1 – ничего экстраординарного с счетчиком не делаем</span>

<span class="mark">  
</span>

**Схема декодера (R, S, I), как видно читателю, данная схема на самом деле является продвинутым мультиплексором.**

<img src="./media/image143.png" style="width:6.77899in;height:3.7in" />

**Реализация инструкций типа B (opcode = 7’d99).**

<img src="./media/image144.png" style="width:6.49653in;height:0.64236in" />

**Про АЛУ (aop) и все “правые” биты декодера.**

<img src="./media/image25.png" style="width:3.77273in;height:1.39273in" />

<img src="./media/image136.png" style="width:4.05921in;height:2.23485in" />

Из-за нашей нумерации команд на АЛУ <span class="mark">aop = {1,1,func3}</span> (две единицы обозначают то, что на выходе АЛУ нам нужен только флаг сравнения, на OUT_ALU же будет просто 0). Также, так-как АЛУ проводит операцию с RD1 и RD2 и никуда результат не записывает, то: <span class="mark">rfwe = 1’d0, SrcA = 2’d0, SrcB = 1’d0, mwe = 1’d0, memi = 5’d0, ws = 1’d0</span>

**Про счетчик.**

Данный тип инструкций отличается от остальных тем, что мы работаем только с счетчиком и результатом сравнения на АЛУ, поэтому акцентируем внимание на левой части архитектуры RISC-V.

<img src="./media/image145.png" style="width:3.78788in;height:2.61814in" />

<span class="mark">B = 1’d1 (переход при C = 1 на константу Imm_B), jal = 1’d0, enpc = 1’d1, jalr = 1’d0</span>

**Реализация инструкции типа J (opcode = 7’d111)**

Да, для одной инструкции выделили целый opcode ( в типе U на 2 инструкции также будет 2 opcode)

<img src="./media/image146.png" style="width:6.49236in;height:0.13889in" />

Отличием от jalr является переход на какую-то константную величину относительно текущего значения счетчика (относительный переход), а не переход на строчку “RA1+const”, которая уже задается абсолютно.

<img src="./media/image136.png" style="width:4.75758in;height:2.61934in" />

<span class="mark">Mwe = 1’d0, Memi = 5’d0, ws = 1’d0, rfwe = 1’d1, (работаем с регистровым файлом, а не с памятью)</span>

<span class="mark">srcA = 2’d1, srcB = 3’d4, aop = 5’d0 (берем значение с PC и 4, делаем сложение (0 операция на АЛУ) и записываем в RF)</span>

<img src="./media/image117.png" style="width:4.41707in;height:3.05303in" />

<span class="mark">Jal = 1’d1 (так-как надо перейти на значение в регистре 1 + константа Imm_J)</span>

<span class="mark">Enpc = 1’d1, jalr = 1’d0, b = 1’d0 (типичные значения на выходах декодера)</span>

**Реализация инструкции типа U (opcode = 7’d23, 7’d25)**

<img src="./media/image147.png" style="width:6.49653in;height:0.25in" />

Я объединил 2 opcode в одно описание, так-как для типа инструкций U opcode играет роль мультиплексора, а сами инструкции выполняют примерно одно и тоже, поэтому я сначала рассмотрю одинаковые параметры декодера для них, а потом уже про различия поговорим.

<img src="./media/image148.png" style="width:6.49444in;height:0.24444in" />

**Одинаково для всех инструкций типа U**

<span class="mark">Mwe = 1’d0, Memi = 5’d0, ws = 1’d0, rfwe = 1’d1, (работаем с регистровым файлом, а не с памятью)</span>

<span class="mark">srcB = 3’d2,enpc = 1’d1, b = 1’d0, jal = 1’d0, jalr = 1’d0, aop = 5’d0</span>

**Для lui (opcode = 7’d55)**

<span class="mark">srcA = 2’d2</span>

**Для auipc (opcode = 7’d23)**

<span class="mark">srcA = 2’d1</span>

**Декодер к простейшему RISC-V на Verilog (полностью). Надо затычку поменять на 0.**

<img src="./media/image149.png" style="width:4.34722in;height:9.75043in" />

# Лекция 8. RISC-V на Verilog

**Введение**

На самом деле, изначально не планировалось разбивать статью про RISC-V на 3(4, если считать декодер) лекции, но после того, как автор увидел примерное число страниц, которое выходит на описание данной темы (порядка 20-30), то было принято решение разделить лекция на несколько частей: архитектурную, декодер , реализацию архитектурной части на Verilog (то есть, в данной статье большая часть содержания – скрины кода и тесты получившегося устройства с некоторыми пояснениями) и прошивка (которая выполняет роль тестирования операций регистр/регистр, регистр/константа и условных переходов) (следующая статья) устройства

**АЛУ к RISC-V.**

АЛУ к данному процессору было реализовано в статье 1 про АЛУ (АЛУ под номером 3), но я напомню некоторые моменты оттуда.

<img src="./media/image23.png" style="width:5.01745in;height:1.2in" />

Для выхода АЛУ (у нас вместо result_0 выход Out_ALU

<img src="./media/image24.png" style="width:4.80553in;height:2.125in" />

Роль флага сравнения у нас будет играть бит C

<img src="./media/image25.png" style="width:3.79687in;height:1.40165in" />

**Описание АЛУ(есть недочеты небольшие, исправленное АЛУ на гитхабе).**

<img src="./media/image27.png" style="width:3.6in;height:9.68in" />

<img src="./media/image28.png" style="width:1.88333in;height:1.25556in" />

<img src="./media/image29.png" style="width:2in;height:1.15511in" />

<img src="./media/image30.png" style="width:2.15833in;height:1.15229in" />

**Data Memory**

<img src="./media/image150.png" style="width:1.27083in;height:1.54561in" />

Данная штуковина практически полностью аналогична регистровому файлу кроме управляющих битов.

<img src="./media/image132.png" style="width:6.49653in;height:1.53158in" />

То есть, залезаем в код для регистрового файла, ставим там пару-тройку мультиплексоров для реализации memi и получаем в итоге Data Memory.

**RTL схема Data Memory**

<img src="./media/image151.png" style="width:6.96528in;height:1.63889in" />

**Описание Data Memory на Verilog.**

<img src="./media/image152.png" style="width:4.22222in;height:4.49729in" />

**Небольшое тестирование Data Memory**

<img src="./media/image153.png" style="width:6.49306in;height:0.92361in" />

<img src="./media/image154.png" style="width:6.49306in;height:0.93056in" />

**Декодер инструкций. Затычку надо поставить 32’d0 (иначе будет веселая константа)**

<img src="./media/image149.png" style="width:4.34722in;height:9.75043in" />

**Счетчик**

Я решил вывести его в отдельный модуль, так-как счетчик практически не связан с остальным процессором (не считая выходы декодера) и занимает довольно много места в коде, что делает его не очень хорошо читаемым.

**Схема счетчика, которую будем описывать на Verilog.**

<img src="./media/image155.png" style="width:1.83333in;height:1.63352in" />

**Описание на Verilog**

<img src="./media/image156.png" style="width:3.59563in;height:3.57143in" />

**Схема, которая синтезировалась**

<img src="./media/image157.png" style="width:6.48819in;height:1.75in" />

Итак, мы реализовали декодер, счетчик, регистровый файл (уж его я не стал дублировать тут), АЛУ, Data Memory и память команд, осталось просто соединить все проводами (и добавить пару-тройку знаковых расширителей и мультиплексоров).

**Схема RISC-V концептуальная**

<img src="./media/image158.png" style="width:4.99167in;height:2.26741in" />

**RTL схема RISC-V (что по описанию на Verilog синтезировалось).**

<img src="./media/image159.png" style="width:7.97275in;height:3.03333in" />

Как читатель может видеть, out_proc ни к чему не подключен, но так и должно быть, так-как данный выход я планирую использовать для тестирования прошивки RISC-V.

В общем-то и все, процессор готов, осталось его протестировать (описание на Verilog будет на следующей страничке). Однако, как писалось выше, автор будет придерживаться “тестированием прошивкой”, где мы будем прошивать RISC-V, и если он на наших примерах работает, то и хорошо (такой поиск тривиальных ошибок), чем мы и займемся в следующей статье.

Как читатель может видеть, простейший однотактный RISC-V весьма прост (да, тавтология) и занимает порядка 135(ядро)+100(АЛУ)+15(command_memory)+45(data memory)+135(декодер)+26(регистровый файл)+38(модули к АЛУ) = 464 строчек кода (порядка 500), что весьма подъемно для реализации за недельки так 2 с чашечкой чая (гикам можно меньше, разрешаю).**  
**

**Описание на Verilog RISC-V (код есть на гитхабе).**

<img src="./media/image160.png" style="width:3.60826in;height:9.56944in" />

# Лекция 9. Прошивка RISC-V.

**Введение**

В данной статье мы будем сначала писать прошивку вручную (аналогично такой же статье про Cobra), а далее уже для более интересных программ пользоваться ассемблером, который получается из C (а затем переводить его в машинный код).

**Ручное программирование RISC-V.**

Как мы выяснили в статье про архитектуру, команды в RISC-V имеют такую кодировку:

<img src="./media/image124.png" style="width:6.86534in;height:1.59849in" />

Для написания чего-то очень простого (например, сложить 8 и 9) нам хватит операции типа регистр/регистр(R) и регистр/константа(I)

<img src="./media/image161.png" style="width:6.76328in;height:0.60606in" />

**Пример 1. Найти 8+9, данные снимаем с выхода регистрового файла (RA1)**

<img src="./media/image162.png" style="width:6.7197in;height:0.43993in" />

Для решения данной простейшей задачи воспользуемся только типом I (opcode = 7’d19).

**Строчка 1. Загрузка 8 в регистр 1 (прибавление 8 к 0, что лежит в регистре 1)**

000000001000 00001 000 00001 0010011

> 
> 0010011<sub>2</sub> = 19 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы*
>
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00001<sub>2</sub>− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *с**к**л**а**д**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000000001000<sub>2</sub> = 8 − *с* *ч**е**м* *с**к**л**а**д**ы**в**а**е**м* *з**н**а**ч**е**н**и**е* *в* *р**е**г**и**с**т**р**е* (*к**о**н**с**т**а**н**т**а*)

*  
*

**Строчка 2. Прибавление 9 к 8, что лежит в регистре 1)**

000000001001 00001 000 00001 0010011

> 
> 0010011<sub>2</sub> = 19 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы*
>
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *р**е**з**у**л**ь**т**а**т* *с**л**о**ж**е**н**и**я*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00001<sub>2</sub>− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *с**к**л**а**д**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000000001001<sub>2</sub> = 9 − *с* *ч**е**м* *с**к**л**а**д**ы**в**а**е**м* *з**н**а**ч**е**н**и**е* *в* *р**е**г**и**с**т**р**е* (*к**о**н**с**т**а**н**т**а*)

**Строчка 3. Вывод результата операции в RA1 (выводим RA1+0)**

000000000000 00001 000 00001 0010011

> 
> 0010011<sub>2</sub> = 19 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы*
>
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *р**е**з**у**л**ь**т**а**т* *с**л**о**ж**е**н**и**я*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00001<sub>2</sub>− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *с**к**л**а**д**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000000000000<sub>2</sub> = 0 − *с* *ч**е**м* *с**к**л**а**д**ы**в**а**е**м* *з**н**а**ч**е**н**и**е* *в* *р**е**г**и**с**т**р**е* (*к**о**н**с**т**а**н**т**а*)

**Итоговая прошивка:**

00000000100000001000000010010011

00000000100100001000000010010011

00000000000000001000000010010011

Что будет на выходе RA1 (out_proc) по event (clk из 0 в 1)

1)  На выходе 0 (8 еще не запасалось)

2)  На выходе 8 (результат операции на АЛУ (8+9) еще не записался)

3)  На выходе 17 (Выводим значение в RA1+0)

Далее же на выходах будут 0

**Результат симуляции RISC-V с такой прошивкой.**

<img src="./media/image163.png" style="width:6.49306in;height:0.3125in" />

Как читатель видит, работает процессор (инструкции с opcode = 19 (I_1) так, как нам нужно

**Пример 2. Реализация (-15+3) с помощью инcтрукций типа R и типа I.**

На самом деле, данную операцию опять-таки можно элементарно реализовать с помощью типа I_1 (opcode = 19), но мы не только прошиваем RISC-V, мы его еще и немного тестируем, поэтому совершаем относительно неоптимальные действия (как сейчас).

**Табличка кодировки инструкций (opcode_R = 7’d51, opcode_I_1 = 7’d19)**

<img src="./media/image161.png" style="width:6.49653in;height:0.58168in" />

**Строчка 1. Загрузка (-15) в регистр 1 (прибавление (-15) к 0, что лежит в регистре 1)**

111111110001 00001 000 00001 0010011

> 
> 0010011<sub>2</sub> = 19 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы*
>
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00001<sub>2</sub>− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *с**к**л**а**д**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 111111110001<sub>2</sub> = −15 − *с* *ч**е**м* *с**к**л**а**д**ы**в**а**е**м* *з**н**а**ч**е**н**и**е* *в* *р**е**г**и**с**т**р**е* (*к**о**н**с**т**а**н**т**а*)

**Строчка 2. Загрузка 3 в регистр 2 (прибавление 3 к 0, что лежит в регистре 0)**

000000000011 00000 000 00010 0010011

> 
> 0010011<sub>2</sub> = 19 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы*
>
> 00010<sub>2</sub> = 2 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00000<sub>2</sub>− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *с**к**л**а**д**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000000000011<sub>2</sub> = 3 − *с* *ч**е**м* *с**к**л**а**д**ы**в**а**е**м* *з**н**а**ч**е**н**и**е* *в* *р**е**г**и**с**т**р**е* (*к**о**н**с**т**а**н**т**а*)

**Строчка 3. Складываем 2 регистр(3) и 1 регистр(-15) и записываем это в 1 регистр**

0000000 00001 00010 000 00001 0110011

> 
> 0110011<sub>2</sub> = 51 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы* (*R*)
>
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *р**е**з**у**л**ь**т**а**т* *о**п**е**р**а**ц**и**и* *н**а* *А**Л**У*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00010<sub>2</sub>− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *м**ы* *п**р**о**в**о**ж**и**м* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*R**A*1)
>
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *м**ы* *п**р**о**в**о**д**и**м* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*R**A*2)
>
> 0000000<sub>2</sub> = 0 − *f**u**n**c**t*7

*  
*

**Строчка 4. Вывод результата операции в RA1 (выводим RA1+0)**

000000000000 00001 000 00001 0010011

> 
> 0010011<sub>2</sub> = 19 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы*
>
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *р**е**з**у**л**ь**т**а**т* *с**л**о**ж**е**н**и**я*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00001<sub>2</sub>− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *с**к**л**а**д**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000000000000<sub>2</sub> = 0 − *с* *ч**е**м* *с**к**л**а**д**ы**в**а**е**м* *з**н**а**ч**е**н**и**е* *в* *р**е**г**и**с**т**р**е* (*к**о**н**с**т**а**н**т**а*)

**Итоговая прошивка:**

11111111000100001000000010010011

00000000001100000000000100010011

00000000000100010000000010110011

00000000000000001000000010010011

Что будет на выходе RA1 (out_proc) по event (clk из 0 в 1)

1)  На выходе 0 (-15 еще не запасалось)

2)  На выходе 0 (3 еще не записалось)

3)  На выходе 3 (Выводит значение RA1 при операции на АЛУ)

4)  На выходе -12 (результат операции на АЛУ, записанный в регистр 1).

Далее же на выходах будут 0

**Результат симуляции RISC-V с такой прошивкой.**

<img src="./media/image164.png" style="width:6.49236in;height:0.31042in" />

Как читатель видит, инструкции типа R работают как надо.

**  
**

**Пример 3. Инструкции типа Branch (умножение -15 на 3 путем сложения).**

<img src="./media/image165.png" style="width:7.00225in;height:0.8in" />

**Опкоды, которые нас понадобятся**

Opcode_B = 7’d99, Opcode_I_1 = 7’d19, Opcode_R = 7’d51

**Строчка 1. Загрузка 3 в регистр 2 (прибавление 3 к 0, что лежит в регистре 0)**

000000000011 00000 000 00010 0010011

> 
> 0010011<sub>2</sub> = 19 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы*
>
> 00010<sub>2</sub> = 2 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00000<sub>2</sub>− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *с**к**л**а**д**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000000000011<sub>2</sub> = 3 − *с* *ч**е**м* *с**к**л**а**д**ы**в**а**е**м* *з**н**а**ч**е**н**и**е* *в* *р**е**г**и**с**т**р**е* (*к**о**н**с**т**а**н**т**а*)

**Строчка 2. Переход на 4 строчки вниз (если счетчик равен 0)**

0000000 00000 00010 000 10000 1100011

> 
> 1100011<sub>2</sub> = 99 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы* (*B*)
>
> 00000 = *н**о**м**е**р* *р**е**г**и**с**т**р**а* 2 (*н**о**л**ь*)
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*р**е**г**и**с**т**р* 1= *р**е**г**и**с**т**р* 2)
>
> 00010<sub>2</sub>− *н**о**м**е**р* *R**A*1 (*с**ч**е**т**ч**и**к*)
>
> 0000000010000<sub>2</sub> = {*I**m**m*<sub>*I*</sub>, 1<sup>′</sup>*d*0}= 16 = 4 \* (4)

**Строчка 3. (прибавление (-15) к значению, что лежит в регистре 1)**

111111110001 00001 000 00001 0010011

> 
> 0010011<sub>2</sub> = 19 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы*
>
> 00001<sub>2</sub> = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00001<sub>2</sub>− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *с**к**л**а**д**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 111111110001<sub>2</sub> = −15 − *с* *ч**е**м* *с**к**л**а**д**ы**в**а**е**м* *з**н**а**ч**е**н**и**е* *в* *р**е**г**и**с**т**р**е* (*к**о**н**с**т**а**н**т**а*)

*  
*

**Строчка 4. (прибавление (-1) к значению, что лежит в регистре 2)**

111111111111 00010 000 00010 0010011

> 
> 0010011<sub>2</sub> = 19 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы*
>
> 00010 = 2 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *о**п**е**р**а**ц**и**ю* *с* *к**о**н**с**т**а**н**т**о**й*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00010− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *с**к**л**а**д**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 111111111111<sub>2</sub> = −1 − *с* *ч**е**м* *с**к**л**а**д**ы**в**а**е**м* *з**н**а**ч**е**н**и**е* *в* *р**е**г**и**с**т**р**е* (*к**о**н**с**т**а**н**т**а*)

**Строчка 5. Вывод значения счетчика в RA1 (выводим RA1+0)**

000000000000 00010 000 00010 0010011

> 
> 0010011<sub>2</sub> = 19 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы*
>
> 00010 = 2 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *р**е**з**у**л**ь**т**а**т* *с**л**о**ж**е**н**и**я*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00010<sub>2</sub>− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *с**к**л**а**д**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000000000000<sub>2</sub> = 0 − *с* *ч**е**м* *с**к**л**а**д**ы**в**а**е**м* *з**н**а**ч**е**н**и**е* *в* *р**е**г**и**с**т**р**е* (*к**о**н**с**т**а**н**т**а*)

**Строчка 6. Переход на 4 строчки наверх (если счетчик больше 0)**

1111111 00010 00000 100 10001 1100011

> 
> 1100011<sub>2</sub> = 99 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы* (*B*)
>
> 00010 = *н**о**м**е**р* *р**е**г**и**с**т**р**а* 2 (*с**ч**е**т**ч**и**к*)
>
> 100<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (0 \< *р**е**г**и**с**т**р* 2)
>
> 00000<sub>2</sub>− *н**о**м**е**р* *р**е**г**и**с**т**р**а* *R**A*1
>
> 11111111110000<sub>2</sub> = {*I**m**m*<sub>*I*</sub>, 1<sup>′</sup>*d*0}=  − 16 = 4 \* (−4)

**Строчка 7. Вывод значения (-15\*3) в RA1 (выводим RA1+0)**

000000000000 00001 000 00001 0010011

> 
> 0010011<sub>2</sub> = 19 − *o**p**c**o**d**e* *д**а**н**н**о**г**о* *т**и**п**а* *к**о**м**а**н**д**ы*
>
> 00001 = 1 − *р**е**г**и**с**т**р*, *в* *к**о**т**о**р**ы**й* *м**ы* *з**а**п**и**с**ы**в**а**е**м* *р**е**з**у**л**ь**т**а**т* *с**л**о**ж**е**н**и**я*
>
> 000<sub>2</sub> − *f**u**n**c*3, *п**о**к**а**з**ы**в**а**е**т* *к**а**к* *б**ы* *о**п**е**р**а**ц**и**ю* *н**а* *А**Л**У* (*с**л**о**ж**е**н**и**е*)
>
> 00001<sub>2</sub>− *р**е**г**и**с**т**р*, *с* *к**о**т**о**р**ы**м* *с**к**л**а**д**ы**в**а**е**м* *к**о**н**с**т**а**н**т**у*
>
> 000000000000<sub>2</sub> = 0 − *с* *ч**е**м* *с**к**л**а**д**ы**в**а**е**м* *з**н**а**ч**е**н**и**е* *в* *р**е**г**и**с**т**р**е* (*к**о**н**с**т**а**н**т**а*)

*  
*

**Итоговая прошивка.**

00000000001100000000000100010011

00000000000000010000100001100011

11111111000100001000000010010011

11111111111100010000000100010011

00000000000000010000000100010011

11111110001000000100100011100011

00000000000000001000000010010011

**Результат симуляции RISC-V с такой прошивкой**

<img src="./media/image166.png" style="width:6.87629in;height:0.68182in" />

Как читатель может увидеть, на симуляции у меня большее число выходных сигналов, это связано с тем, что я допустил ошибку в PC и искал ее, симулируя процессор с разными прошивками (думал, в декодере ошибся, но там все, как оказалось, было верно).

# Полезные ссылки (+источники).

1)  Гитхаб методички <https://github.com/YuraThomas/Methoda/tree/main>

2)  АПС МИЭТ (хотя много формализма и воды, но вот для тех, кто частично шарит в теме данный ресурс будет полезен, основывался я большей частью на нем, но сделал в более последовательном и логичном по моей точке зрения стиле).

    1.  YouTube канал АПС <https://www.youtube.com/@digital_machines>

    2.  Гитхаб АПС <https://github.com/MPSU/APS>

3)  Телеграм канал авторов, есть разные статьи (t.me/botdrakosha)

4)  Харис-Харис, книжка по RISC-V (как бы я их не ругал за слишком формальный и одновременно полный воды рассказ, но основывался я в том числе и на них)
